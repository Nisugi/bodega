name: Convert JSON to JS and Deploy to Pages

on:
  push:
    branches: [ main ]
    paths: [ '*.json' ]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build-and-deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Convert JSON files to JS modules
      run: |
        echo "Converting JSON files to JavaScript modules..."

        # Create data directory for JS modules
        mkdir -p data

        # Convert each JSON file to a JS module
        for jsonfile in *.json; do
          if [ -f "$jsonfile" ]; then
            basename=$(basename "$jsonfile" .json)
            echo "Converting $jsonfile to data/${basename}.js"

            # Create JS module that exports the JSON data
            echo "export const data = " > "data/${basename}.js"
            cat "$jsonfile" >> "data/${basename}.js"
            echo ";" >> "data/${basename}.js"
          fi
        done

        # List created files for verification
        echo "Created JS modules:"
        ls -la data/

    - name: Update data-loader.js to use modules
      run: |
        echo "Updating data-loader.js to use JS modules instead of fetch..."

        # Create the updated data-loader.js
        cat > data-loader-updated.js << 'EOF'
        class DataLoader {
            constructor() {
                this.towns = [
                    'wehnimers_landing',
                    'zul_logoth',
                    'solhaven',
                    'teras_isle',
                    'icemule_trace',
                    'ta_vaalor',
                    'ta_illistim',
                    'rivers_rest',
                    'mist_harbor'
                ];
                this.allData = [];
                this.currentPage = 1;
                this.itemsPerPage = 100;
                this.totalPages = 1;
            }

            async loadAllData() {
                console.log('Loading data from JS modules...');
                const loadPromises = this.towns.map(town => this.loadTownData(town));

                try {
                    const results = await Promise.all(loadPromises);
                    this.allData = results.flat().filter(item => item !== null);
                    console.log(`Loaded ${this.allData.length} total items from ${this.towns.length} towns`);
                    return this.allData;
                } catch (error) {
                    console.error('Error loading data:', error);
                    return [];
                }
            }

            async loadTownData(townName) {
                try {
                    console.log(`Loading data for ${townName}...`);

                    // Dynamically import the JS module
                    const module = await import(`./data/${townName}.js`);
                    const rawData = module.data;

                    if (!Array.isArray(rawData)) {
                        console.warn(`No data array found for ${townName}`);
                        return [];
                    }

                    console.log(`Processing ${rawData.length} items from ${townName}`);

                    return rawData.map(item => {
                        try {
                            return this.processItem(item, townName);
                        } catch (error) {
                            console.warn('Error processing item:', item.name, error);
                            return null;
                        }
                    }).filter(item => item !== null);

                } catch (error) {
                    console.error(`Failed to load ${townName}:`, error);
                    return [];
                }
            }

            processItem(item, townName) {
                if (!item || !item.name) {
                    return null;
                }

                // Parse basic properties
                const enhant = this.parseEnchant(item.details?.raw || []);
                const price = this.parsePrice(item.price);

                // Clean up capacity detection
                let capacity = null;
                if (item.details && item.details.raw) {
                    for (const line of item.details.raw) {
                        const capacityMatch = line.match(/can store a (.*?) amount/i);
                        if (capacityMatch) {
                            capacity = capacityMatch[1].toLowerCase();
                            break;
                        }
                    }
                }

                // Parse advanced properties from raw text
                const advancedProps = this.parseAdvancedProperties(item);

                // Build enhanced item object
                return {
                    id: item.id,
                    name: item.name,
                    price: price,
                    priceOriginal: item.price,
                    room: item.room || 'Unknown',
                    shop: item.shop || 'Unknown Shop',
                    town: townName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                    townKey: townName,
                    enchant: enhant,
                    capacity: capacity,
                    details: item.details,
                    ...advancedProps
                };
            }

            parseEnchant(rawLines) {
                for (const line of rawLines) {
                    const enchantMatch = line.match(/\+(\d+)/) || line.match(/(\d+)x enchanted/);
                    if (enchantMatch) {
                        return parseInt(enchantMatch[1]);
                    }
                }
                return 0;
            }

            parsePrice(priceStr) {
                if (!priceStr) return 0;

                const cleanPrice = priceStr.replace(/,/g, '').replace(/[^\d]/g, '');
                return parseInt(cleanPrice) || 0;
            }

            parseAdvancedProperties(item) {
                const properties = {
                    capacity: null,
                    capacityLevel: null,
                    armorType: null,
                    weaponType: null,
                    shieldType: null,
                    itemType: null,
                    wearLocation: null,
                    flares: [],
                    isWeapon: false,
                    isArmor: false,
                    isShield: false,
                    isContainer: false,
                    isJewelry: false,
                    charges: null,
                    spell: null,
                    blessing: null
                };

                (item.details?.raw || []).forEach(line => {
                    // Capacity parsing
                    const capacityMatch = line.match(/can store a (.*?) amount/i);
                    if (capacityMatch) {
                        properties.capacity = line.trim();
                        properties.capacityLevel = capacityMatch[1].toLowerCase();
                        properties.isContainer = true;
                    }

                    // Armor type parsing
                    if (line.match(/\b(cloth|leather|scale|chain|plate)\b/i)) {
                        const armorMatch = line.match(/\b(cloth|leather|scale|chain|plate)\b/i);
                        if (armorMatch) {
                            properties.armorType = armorMatch[1].toLowerCase();
                            properties.isArmor = true;
                            properties.itemType = 'armor';
                        }
                    }

                    // Shield detection
                    if (line.match(/\b(small|medium|large|tower)\s+shield/i) ||
                        line.match(/\bshield\b/i)) {
                        properties.isShield = true;
                        properties.itemType = 'shield';
                        const shieldMatch = line.match(/\b(small|medium|large|tower)\s+shield/i);
                        if (shieldMatch) {
                            properties.shieldType = shieldMatch[1].toLowerCase();
                        }
                    }

                    // Wear location detection
                    if (line.match(/worn/i)) {
                        const wearMatch = line.match(/worn\s+(?:on\s+)?(?:the\s+)?([\w\s]+)/i) ||
                                         line.match(/\b(pin-worn|belt-worn|shoulder-worn)\b/i);
                        if (wearMatch) {
                            properties.wearLocation = wearMatch[1].toLowerCase().trim();
                        }
                    }

                    // Enhancive detection
                    if (line.match(/enhancive/i)) {
                        properties.isEnhancive = true;
                    }

                    // Lightened/Deepened detection
                    if (line.match(/lightened/i)) {
                        properties.isLightened = true;
                        if (line.match(/max.*lightened/i)) {
                            properties.isMaxLightened = true;
                        }
                    }
                    if (line.match(/deepened/i)) {
                        properties.isDeepened = true;
                        if (line.match(/max.*deepened/i)) {
                            properties.isMaxDeepened = true;
                        }
                    }

                    // Persistence detection
                    if (line.match(/persists/i)) {
                        properties.persists = true;
                    }

                    // Crumbly detection
                    if (line.match(/crumbly/i)) {
                        properties.crumbly = true;
                    }

                    // Flares detection
                    const flareMatch = line.match(/(fire|ice|lightning|earth|air|water|steam|plasma|disintegration|disruption|unbalance|acid|vacuum|vibration)\s+flares?/i);
                    if (flareMatch) {
                        properties.flares.push(flareMatch[1].toLowerCase());
                    }

                    // Spell detection
                    if (line.match(/\bspell\b/i) && !line.match(/\bno spell\b/i)) {
                        properties.spell = line.trim();
                    }

                    // Charges detection
                    const chargeMatch = line.match(/(\d+)\s+charges?/i);
                    if (chargeMatch) {
                        properties.charges = parseInt(chargeMatch[1]);
                    }

                    // Item type detection - be more specific
                    if (line.match(/is.*jewelry/i) ||
                        line.match(/\b(ring|necklace|bracelet|earring|pendant|amulet|brooch|pin)\b/i)) {
                        properties.isJewelry = true;
                        properties.itemType = 'jewelry';
                    }

                    // Container detection - only if it has storage capacity
                    if (line.match(/can store.*amount/i) ||
                        line.match(/container.*capacity/i) ||
                        line.match(/\b(bag|sack|backpack|pouch|satchel|chest|box|case|trunk|basket)\b/i)) {
                        properties.isContainer = true;
                        properties.itemType = 'container';
                    }

                    // Blessing detection
                    if (line.match(/blessed/i) || line.match(/holy/i)) {
                        properties.blessing = 'holy';
                    }
                });

                // Use existing skill field to determine weapons
                if (item.details?.skill) {
                    properties.skill = item.details.skill.toLowerCase();
                    // Only items with weapon skills are weapons (expanded list)
                    const weaponSkills = [
                        'edged weapons', 'blunt weapons', 'two handed weapons', 'twohanded weapons',
                        'polearms', 'ranged weapons', 'thrown weapons', 'brawling'
                    ];
                    if (weaponSkills.includes(properties.skill)) {
                        properties.isWeapon = true;
                        properties.weaponType = properties.skill;
                        properties.itemType = 'weapon';
                    }
                }

                // Determine general item type if not already set
                if (!properties.itemType) {
                    if (properties.isWeapon) properties.itemType = 'weapon';
                    else if (properties.isArmor) properties.itemType = 'armor';
                    else if (properties.isShield) properties.itemType = 'shield';
                    else if (properties.isContainer) properties.itemType = 'container';
                    else if (properties.isJewelry) properties.itemType = 'jewelry';
                    else properties.itemType = 'miscellaneous';
                }

                return properties;
            }

            getFilteredData(filters = {}) {
                let filtered = [...this.allData];

                // Apply filters
                if (filters.search) {
                    const searchTerm = filters.search.toLowerCase();
                    filtered = filtered.filter(item =>
                        item.name.toLowerCase().includes(searchTerm) ||
                        item.shop.toLowerCase().includes(searchTerm) ||
                        (item.details?.raw || []).some(line => line.toLowerCase().includes(searchTerm))
                    );
                }

                if (filters.town && filters.town !== '') {
                    filtered = filtered.filter(item => item.townKey === filters.town);
                }

                if (filters.priceRange && filters.priceRange !== '') {
                    const [min, max] = filters.priceRange.split('-').map(Number);
                    filtered = filtered.filter(item => item.price >= min && item.price <= max);
                }

                if (filters.enchant && filters.enchant !== '') {
                    const minEnchant = parseInt(filters.enchant);
                    filtered = filtered.filter(item => item.enchant >= minEnchant);
                }

                if (filters.itemType && filters.itemType !== '') {
                    filtered = filtered.filter(item => item.itemType === filters.itemType);
                }

                if (filters.capacity && filters.capacity !== '') {
                    filtered = filtered.filter(item => item.capacityLevel === filters.capacity);
                }

                if (filters.armorType && filters.armorType !== '') {
                    filtered = filtered.filter(item => item.armorType === filters.armorType);
                }

                if (filters.shieldType && filters.shieldType !== '') {
                    filtered = filtered.filter(item => item.shieldType === filters.shieldType);
                }

                if (filters.wearLocation && filters.wearLocation !== '') {
                    filtered = filtered.filter(item =>
                        item.wearLocation && item.wearLocation.includes(filters.wearLocation)
                    );
                }

                if (filters.skill && filters.skill !== '') {
                    filtered = filtered.filter(item => item.skill === filters.skill);
                }

                // Boolean filters
                if (filters.enhancive) {
                    filtered = filtered.filter(item => item.isEnhancive);
                }

                if (filters.maxLight) {
                    filtered = filtered.filter(item => item.isMaxLightened);
                }

                if (filters.maxDeep) {
                    filtered = filtered.filter(item => item.isMaxDeepened);
                }

                if (filters.persists) {
                    filtered = filtered.filter(item => item.persists);
                }

                if (filters.crumbly) {
                    filtered = filtered.filter(item => item.crumbly);
                }

                if (filters.flares) {
                    filtered = filtered.filter(item => item.flares && item.flares.length > 0);
                }

                if (filters.spell) {
                    filtered = filtered.filter(item => item.spell);
                }

                if (filters.blessed) {
                    filtered = filtered.filter(item => item.blessing);
                }

                // Apply sorting
                if (filters.sort) {
                    switch (filters.sort) {
                        case 'name':
                            filtered.sort((a, b) => a.name.localeCompare(b.name));
                            break;
                        case 'price-asc':
                            filtered.sort((a, b) => a.price - b.price);
                            break;
                        case 'price-desc':
                            filtered.sort((a, b) => b.price - a.price);
                            break;
                        case 'enchant-desc':
                            filtered.sort((a, b) => b.enchant - a.enchant);
                            break;
                        case 'town':
                            filtered.sort((a, b) => a.town.localeCompare(b.town));
                            break;
                        case 'type':
                            filtered.sort((a, b) => a.itemType.localeCompare(b.itemType));
                            break;
                        case 'capacity':
                            const capacityOrder = {
                                'very small': 1, 'small': 2, 'fairly small': 3, 'slightly small': 4,
                                'somewhat small': 5, 'medium': 6, 'slightly large': 7, 'fairly large': 8,
                                'large': 9, 'significant': 10, 'particularly large': 11, 'very large': 12,
                                'huge': 13, 'gigantic': 14
                            };
                            filtered.sort((a, b) => {
                                const aOrder = capacityOrder[a.capacityLevel] || 0;
                                const bOrder = capacityOrder[b.capacityLevel] || 0;
                                return bOrder - aOrder;
                            });
                            break;
                    }
                }

                return filtered;
            }

            getPageData(data, page = 1) {
                const startIndex = (page - 1) * this.itemsPerPage;
                const endIndex = startIndex + this.itemsPerPage;
                this.totalPages = Math.ceil(data.length / this.itemsPerPage);
                this.currentPage = page;

                return data.slice(startIndex, endIndex);
            }

            getTowns() {
                return [...new Set(this.allData.map(item => item.town))].sort();
            }

            getStats() {
                const towns = this.getTowns();
                const shops = [...new Set(this.allData.map(item => item.shop))];

                return {
                    totalItems: this.allData.length,
                    totalShops: shops.length,
                    totalTowns: towns.length,
                    lastUpdated: new Date().toLocaleDateString()
                };
            }

            // Backward compatibility method
            getAllItems() {
                return this.allData;
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', async function() {
            window.dataLoader = new DataLoader();

            // Automatically load data
            await window.dataLoader.loadAllData();

            // Dispatch custom event to notify when data is loaded
            window.dispatchEvent(new CustomEvent('dataLoaded'));
        });
        EOF

        # Replace the original data-loader.js
        mv data-loader-updated.js data-loader.js

        echo "Successfully updated data-loader.js to use JS modules"

    - name: Setup Pages
      uses: actions/configure-pages@v4

    - name: Upload artifact
      uses: actions/upload-pages-artifact@v3
      with:
        path: '.'

    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4